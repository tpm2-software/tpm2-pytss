import site
import sys
import os
from setuptools import setup
from setuptools.command.build_ext import build_ext
from pkgconfig import pkgconfig
from pycparser import c_parser, preprocess_file
from pycparser.c_ast import (
    Typedef,
    TypeDecl,
    IdentifierType,
    Struct,
    ArrayDecl,
    Union,
    Enum,
)
from textwrap import dedent
from cffi import cparser

# workaround bug https://github.com/pypa/pip/issues/7953
site.ENABLE_USER_SITE = "--user" in sys.argv[1:]


class type_generator(build_ext):
    cares = set(
        (
            "TPM2_ALG_ID",
            "TPM2_ST",
            "TPM2_ECC_CURVE",
            "TPM2_CC",
            "TPM2_CAP",
            "TPM2_PT",
            "TPM2_PT_PCR",
            "TPMA_SESSION",
            "TPMA_LOCALITY",
            "TPMA_NV",
            "TPMA_CC",
            "TPMA_OBJECT",
            "TPMA_ALGORITHM",
            "TPM2_HANDLE",
            "TPM2_GENERATED",
            "ESYS_TR",
            "TSS2_POLICY_PCR_SELECTOR",
        )
    )

    type_mapping = {
        "TPM2_ALG_ID": "TPM2_ALG",
        "TPMI_RH_HIERARCHY": "TPM2_RH",
        "TPMI_RH_ENABLES": "TPM2_RH",
        "TPMI_RH_HIERARCHY_AUTH": "TPM2_RH",
        "TPMI_RH_HIERARCHY_POLICY": "TPM2_RH",
        "TPMI_RH_PLATFORM": "TPM2_RH",
        "TPMI_RH_OWNER": "TPM2_RH",
        "TPMI_RH_ENDORSEMENT": "TPM2_RH",
        "TPMI_RH_PROVISION": "TPM2_RH",
        "TPMI_RH_CLEAR": "TPM2_RH",
        "TPMI_RH_NV_AUTH": "TPM2_RH",
        "TPMI_RH_LOCKOUT": "TPM2_RH",
        "TPMI_RH_NV_INDEX": "TPM2_RH",
        "TPMI_RH_AC": "TPM2_RH",
        "TPMI_RH_ACT": "TPM2_RH",
    }

    map_template = """
    # SPDX-License-Identifier: BSD-2

    # this file is autogenerated during the build

    _type_map = {{
    {mstr}
    }}

    _element_type_map = {{
    {estr}
    }}
    """

    version_template = """
    # SPDX-License-Identifier: BSD-2
    # this file is autogenerated during the build

    _versions = {{
    {vstr}
    }}
    """

    version_libs = ("tss2-esys", "tss2-fapi", "tss2-policy", "tss2-tcti-spi-helper")

    def get_types(self, ast):
        tm = dict()
        for v in ast:
            if (
                isinstance(v, Typedef)
                and isinstance(v.type, TypeDecl)
                and isinstance(v.type.type, (IdentifierType, Enum))
            ):
                if hasattr(v.type.type, "names"):
                    names = v.type.type.names
                elif hasattr(v.type.type, "name"):
                    names = [v.type.type.name]
                name = " ".join(names)
                if v.name in self.type_mapping:
                    tm[v.name] = self.type_mapping[v.name]
                elif name in self.type_mapping:
                    tm[v.name] = self.type_mapping[name]
                elif name in self.cares:
                    self.cares.add(v.name)
                    tm[v.name] = name
                elif v.name in self.cares:
                    tm[v.name] = v.name
        return tm

    def get_fields(self, v, tm):
        fields = list()
        nf = 0
        for d in v.decls:
            nf = nf + 1
            if not isinstance(d.type.type, (IdentifierType, Enum)):
                continue
            dn = d.name
            if hasattr(d.type.type, "names"):
                names = d.type.type.names
            elif hasattr(d.type.type, "name"):
                names = [d.type.type.name]
            tname = " ".join(names)
            if tname not in tm:
                continue
            fields.append((dn, tm[tname]))
        return fields

    def get_array_fields(self, v, tm):
        fields = list()
        nf = 0
        for d in v.decls:
            nf = nf + 1
            if not isinstance(d.type, ArrayDecl):
                continue
            tname = " ".join(d.type.type.type.names)
            if tname not in tm:
                continue
            fields.append(tm[tname])
        return fields

    def get_first_struct(self, v):
        if isinstance(v, (Struct, Union)):
            return v
        while hasattr(v, "type"):
            v = v.type
            if isinstance(v, (Struct, Union)):
                return v
        return None

    def generate_mappings(self, ast, tm):
        mapping = dict()
        element_mapping = dict()
        for v in ast:
            if isinstance(v, Typedef):
                name = v.name
            v = self.get_first_struct(v)
            if v is None or getattr(v, "decls") is None:
                continue
            fields = self.get_fields(v, tm)
            for f in fields:
                mapping[(name, f[0])] = f[1]
            afields = self.get_array_fields(v, tm)
            for af in afields:
                element_mapping[name] = af
        return (mapping, element_mapping)

    def get_mappings(self):
        pk = pkgconfig.parse("tss2-esys")
        header_path = None
        for ip in pk["include_dirs"]:
            hp = os.path.join(ip, "tss2_tpm2_types.h")
            if os.path.isfile(hp):
                header_path = hp
                break
            hp = os.path.join(ip, "tss2", "tss2_tpm2_types.h")
            if os.path.isfile(hp):
                header_path = hp
                break
        if header_path is None:
            raise RuntimeError(
                f"unable to find tss2_tpm2_types.h in {pk['include_dirs']}"
            )
        pdata = preprocess_file(
            header_path, cpp_args=["-D__extension__=", "-D__attribute__(x)="]
        )
        parser = c_parser.CParser()
        ast = parser.parse(pdata, "tss2_tpm2_types.h")
        tm = self.get_types(ast)
        (mapping, element_mapping) = self.generate_mappings(ast, tm)
        if pkgconfig.exists("tss2-policy"):
            pk = pkgconfig.parse("tss2-policy")
            for ip in pk["include_dirs"]:
                hp = os.path.join(ip, "tss2_policy.h")
                if os.path.isfile(hp):
                    policy_header_path = hp
                    break
                hp = os.path.join(ip, "tss2", "tss2_policy")
                if os.path.isfile(hp):
                    policy_header_path = hp
                    break
            if policy_header_path:
                pdata = preprocess_file(
                    policy_header_path,
                    cpp_args=[
                        "-D__extension__=",
                        "-D__attribute__(x)=",
                        "-D__float128=long double",
                        "-D_FORTIFY_SOURCE=0",
                    ],
                )
                parser = c_parser.CParser()
                past = parser.parse(pdata, "tss2_policy.h")
                ptm = self.get_types(past)
                tm.update(ptm)
                (pmapping, pelement_mapping) = self.generate_mappings(past, ptm)
                mapping.update(pmapping)
                element_mapping.update(pelement_mapping)
        return (mapping, element_mapping)

    def get_versions(self):
        versions = dict()
        for lib in self.version_libs:
            try:
                versions[lib] = pkgconfig.modversion(lib)
            except pkgconfig.PackageNotFoundError:
                # Library not installed, ignore
                pass
        return versions

    def run(self):
        super().run()
        type_map, element_type_map = self.get_mappings()
        mstr = ""
        for k, v in type_map.items():
            (t, f) = k
            mstr = mstr + f'    ("{t}", "{f}"): "{v}",\n'
        estr = ""
        for k, v in element_type_map.items():
            estr = estr + f'    "{k}": "{v}",\n'

        versions = self.get_versions()
        vstr = ""
        for k, v in versions.items():
            vstr = vstr + f'    "{k}": "{v}",\n'

        p = os.path.join(self.build_lib, "tpm2_pytss/internal/type_mapping.py")
        sp = os.path.join(
            os.path.dirname(__file__), "src/tpm2_pytss/internal/type_mapping.py"
        )

        vp = os.path.join(self.build_lib, "tpm2_pytss/internal/versions.py")
        svp = os.path.join(
            os.path.dirname(__file__), "src/tpm2_pytss/internal/versions.py"
        )

        print(f"generated _type_map with {len(type_map)} mappings in {p} and {sp}")
        print(f"generated _element_type_map with {len(element_type_map)} mappings")
        print(f"generated _versions with {len(versions)} versions")

        stempl = dedent(self.map_template)
        mout = stempl.format(mstr=mstr, estr=estr)

        vtempl = dedent(self.version_template)
        vout = vtempl.format(vstr=vstr)

        if not self.dry_run:
            self.mkpath(os.path.dirname(p))
            with open(p, "wt") as tf:
                tf.seek(0)
                tf.truncate(0)
                tf.write(mout)
            with open(vp, "wt") as vf:
                vf.seek(0)
                vf.truncate(0)
                vf.write(vout)

        if self.inplace:
            self.copy_file(p, sp)
            self.copy_file(vp, svp)


class type_hints_generator(type_generator):
    is_int = set(("int",))
    callbacks = dict()
    functions = dict()

    macro_types = (
        ("TPM2_ALG_", "TPM2_ALG"),
        ("ESYS_TR_", "ESYS_TR"),
        ("TPM2_ECC_", "TPM2_ECC"),
        ("TPM2_RH_", "TPM2_RH"),
        ("TPM2_SU_", "TPM2_SU"),
        ("TPMA_OBJECT_", "TPMA_OBJECT"),
        ("TPM2_CC_", "TPM2_CC"),
        ("TPM2_SPEC_", "TPM2_SPEC"),
        ("TPM2_GENERATED_", "TPM2_GENERATED"),
        ("TPM2_RC_", "TPM2_RC"),
        ("TSS2_RC_", "TSS2_RC"),
        ("TPM2_EO_", "TPM2_EO"),
        ("TPM2_ST_", "TPM2_ST"),
        ("TPM2_SE_", "TPM2_SE"),
        ("TPM2_CAP_", "TPM2_CAP"),
        ("TPM_AT_", "TPM_AT"),
        ("TPM2_PT_", "TPM2_PT"),
        ("TPM2_PT_VENDOR_", "TPM2_PT_VENDOR"),
        ("TPM2_PT_FIRMWARE_", "TPM2_PT_FIRMWARE"),
        ("TPM2_PT_HR_", "TPM2_PT_HR"),
        ("TPM2_PT_NV_", "TPM2_PT_NV"),
        ("TPM2_PT_CONTEXT_", "TPM2_PT_CONTEXT"),
        ("TPM2_PT_PS_", "TPM2_PT_PS"),
        ("TPM2_PT_AUDIT_", "TPM2_PT_AUDIT"),
        ("TPM2_PT_PCR_", "TPM2_PT_PCR"),
        ("TPM2_PS_", "TPM2_PS"),
        ("TPM2_HT_", "TPM2_HT"),
        ("TPMA_SESSION_", "TPMA_SESSION"),
        ("TPMA_LOCALITY_", "TPMA_LOCALITY"),
        ("TPM2_NT_", "TPM2_NT"),
        ("TPM2_HR_", "TPM2_HR"),
        ("TPM2_HC_", "TPM2_HC"),
        ("TPM2_CLOCK_", "TPM2_CLOCK"),
        ("TPMA_NV_", "TPMA_NV"),
        ("TPMA_CC_", "TPMA_CC"),
        ("TPMA_ALGORITHM_", "TPMA_ALGORITHM"),
        ("TPMA_PERMANENT_", "TPMA_PERMANENT"),
        ("TPMA_STARTUP_", "TPMA_STARTUP"),
        ("TPMA_MEMORY_", "TPMA_MEMORY"),
        ("TPM2_MAX_", "TPM2_MAX"),
        ("TPMA_MODES_", "TPMA_MODES"),
    )

    def macro_to_type(self, macro):
        mt = "int"
        ml = 0
        for prefix, tn in self.macro_types:
            pl = len(prefix)
            if macro.startswith(prefix) and pl > ml:
                mt = tn
                ml = pl
        return mt

    def _make_callback_output(self, cname):
        callback = self.callbacks[cname]
        rt, args = callback
        paramtypes = list()
        for _, at in args:
            paramtypes.append(at)
        cbdef = f"Callable[[{', '.join(paramtypes)}], {rt}]"
        return cbdef

    def build_function(self, d):
        args = list()
        for param in d.args.params:
            pn = param.name
            if pn is None:
                # if the param doesn't have a name, ignore
                continue
            elif isinstance(
                param.type,
                (cparser.pycparser.c_ast.PtrDecl, cparser.pycparser.c_ast.ArrayDecl),
            ):
                ft = "CData"
                if isinstance(
                    param.type.type, cparser.pycparser.c_ast.TypeDecl
                ) and isinstance(
                    param.type.type.type, cparser.pycparser.c_ast.IdentifierType
                ):
                    tn = (
                        param.type.type.type.names[0]
                        if param.type.type.type.names
                        else None
                    )
                    if tn in ("char", "uint8_t"):
                        ft = "CData | bytes"
            elif isinstance(
                param.type, cparser.pycparser.c_ast.TypeDecl
            ) and isinstance(param.type.type, cparser.pycparser.c_ast.IdentifierType):
                tn = param.type.type.names[0]
                if tn in self.is_int:
                    ft = "int"
                elif tn in self.callbacks:
                    ft = self._make_callback_output(tn)
            else:
                raise ValueError(f"unable to handle C type {param.type}")
            args.append((pn, ft))
        rt = "CData"
        if isinstance(d.type, cparser.pycparser.c_ast.TypeDecl) and isinstance(
            d.type.type, cparser.pycparser.c_ast.IdentifierType
        ):
            tn = d.type.type.names[0]
            if tn in self.is_int:
                rt = "int"
            elif tn == "void":
                rt = "None"
            else:
                rt = "CData"

        return (rt, tuple(args))

    def write_type_hints(self, macros):
        output = dedent(
            """
            # SPDX-License-Identifier: BSD-2
            # This file is generated during the build process.
            from typing import Callable
            from .ffi import CData

            # Defines
            """
        )

        mtl = [x for _, x in self.macro_types]
        output += f"from ..constants import {', '.join(mtl)}\n"

        for m in macros:
            mt = self.macro_to_type(m)
            output += f'{m}: "{mt}"\n'

        output += "\n# Callback definitions\n"
        for cname in self.callbacks:
            cbdef = self._make_callback_output(cname)
            output += f"{cname}: {cbdef}\n"

        output += "\n# Function definitions\n"
        for fname, function in self.functions.items():
            rt, args = function
            params = list()
            for an, at in args:
                if an == "in":
                    an = "in_"
                params.append(f"{an}: {at}")
            output += f"def {fname}({', '.join(params)}) -> {rt}:...\n"

        p = os.path.join(self.build_lib, "tpm2_pytss/_libtpm2_pytss/lib.pyi")
        sp = os.path.join(
            os.path.dirname(__file__), "src/tpm2_pytss/_libtpm2_pytss/lib.pyi"
        )

        if not self.dry_run:
            self.mkpath(os.path.dirname(p))
            with open(p, "wt") as tf:
                tf.seek(0)
                tf.truncate(0)
                tf.write(output)

        if self.inplace:
            self.copy_file(p, sp)

    def run(self):
        super().run()

        with open("libesys.h", "r") as sf:
            cdata = sf.read()

        parser = cparser.Parser()
        ast, macros, _ = parser._parse(cdata)

        for d in ast:
            name = d.name
            if isinstance(name, str) and name.startswith("__cffi_"):
                # internal cffi stuff, ignore
                continue
            if isinstance(d, cparser.pycparser.c_ast.Typedef):
                d = d.type
            if isinstance(
                d.type,
                (
                    cparser.pycparser.c_ast.Struct,
                    cparser.pycparser.c_ast.Union,
                    cparser.pycparser.c_ast.Enum,
                ),
            ):
                # ignore unions, structs and enums
                pass
            elif isinstance(d.type, cparser.pycparser.c_ast.IdentifierType):
                # check if type is int, otherwise ignore
                if len(d.type.names) == 0:
                    break
                tn = d.type.names[0]
                if tn in self.is_int:
                    self.is_int.add(name)
            elif isinstance(d, cparser.pycparser.c_ast.PtrDecl) and isinstance(
                d.type, cparser.pycparser.c_ast.FuncDecl
            ):
                rt, args = self.build_function(d.type)
                self.callbacks[name] = (rt, args)
            elif isinstance(d, cparser.pycparser.c_ast.Decl) and isinstance(
                d.type, cparser.pycparser.c_ast.FuncDecl
            ):
                rt, args = self.build_function(d.type)
                self.functions[name] = (rt, args)
        self.write_type_hints(macros)


setup(
    use_scm_version=True,
    cffi_modules=["scripts/libtss2_build.py:ffibuilder"],
    cmdclass={"build_ext": type_hints_generator},
)
